<!DOCTYPE html>
<!-- cse6242 project -->

<!-- run: http-server & -->
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mouse Brain Cell Data Visualization</title>
  <link rel="icon" href="web_icon.png" type="image/png"> <!-- Specify the path to your PNG icon file -->
  <style>
    .d3-tip {
      line-height: 1;
      padding: 6px;
      background: rgba(240, 240, 240, 0.95);
      color: #333;
      border-radius: 4px;
      font-size: 12px;
    }

    /* Creates a small triangle extender for the tooltip */
    .d3-tip:after {
      box-sizing: border-box;
      display: inline;
      font-size: 10px;
      width: 100%;
      line-height: 1;
      color: rgba(240, 240, 240, 0.95);
      content: "\25BC";
      position: absolute;
      text-align: center;
    }

    /* Style northward tooltips specifically */
    .d3-tip.n:after {
      margin: -2px 0 0 0;
      top: 100%;
      left: 0;
    }

    .d3-tip h5{
      font-size: 13px;
      font-weight: 600;
      margin: 2px 10px 4px 2px;
    }

    .d3-tip thead td {
      border-bottom: 1px solid #ccc;
      font-size: 10px;
      font-weight: 600;
    }

    .d3-tip td {
      padding: 2px 10px 2px 2px;
    }

    .d3-tip thead tr {
      paddin-top: 10px;
    }

    body {
      background-color: #000;
      /* Black background */
      color: #fff;
      /* White text */
      font-family: Arial, sans-serif;
      overflow-x: hidden;
      /* Hide horizontal scrollbar */
      margin: 0;
      /* Remove default margins */
      padding: 0;
      /* Remove default padding */
    }

    #container {
      width: 80%;
      margin: 0 auto;
      padding-top: 20px;
      text-align: center;
      position: relative;
      /* Relative position for absolute positioning of dropdown */
    }

    .button {
      background-color: #444;
      /* Dark gray button */
      color: #fff;
      /* White text */
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      margin-right: 10px;
    }

    .button:hover {
      background-color: #666;
      /* Light gray on hover */
    }

    .icon {
      width: 20px;
      height: 15px;
      position: absolute;
      /* Position the icon absolutely */
      top: 80px;
      /* Align icon with the top of the page */
      left: -12%;
      /* Align icon with the left edge of the page */
      cursor: pointer;
      transition: left 0.5s ease;
      /* Smooth transition */
      z-index: 2;
      /* Ensure icon appears above other elements */
    }

    #dropdownContainer {
      position: absolute;
      top: 80px;
      left: -550px;
      /* Initially hidden */
      width: 200px;
      height: 100%;
      background-color: #222;
      /* Dark gray background */
      transition: left 0.5s ease;
      /* Smooth transition */
      z-index: 1;
    }

    #dropdownContent {
      padding: 20px;
      height: 100%;
      overflow-y: auto;
      /* Enable vertical scrolling if content exceeds height */
    }

    .dropdownItem {
      color: #fff;
      /* White text */
      padding: 10px 0;
      border-bottom: 1px solid #444;
      /* Dark gray border */
      cursor: pointer;
    }

    .dropdownItem:hover {
      background-color: #333;
      /* Slightly lighter gray on hover */
    }

    #scatterplot {
      margin: 20px auto;
      /* Center the scatter plot horizontally */
      width: calc(98% - 220px);
      /* Adjust width to leave space for legend */
      position: relative;
      top: 30px;
      z-index: 0;
      /* Ensure scatter plot appears below other elements */
      float: left;
      /* Align scatter plot to the left */
    }

    .legend {
      text-align: left;
      /* Align legend to the left */
      width: 220px;
      /* Adjust width as needed */
      position: absolute;
      top: 150px;
      /* Align legend with the top of the scatter plot */
      right: -20px;
      /* Align legend to the right */
      transform: translateY(-20%);
      /* Adjust position to center the legend vertically */
      z-index: 2;
      /* Ensure legend appears above other elements */
    }

    .legend-item {
      margin-right: 10px;
      cursor: pointer;
    }

    .legend-item:hover {
      font-weight: bold;
    }

    #plotLegendContainer {
      position: relative;
    }
  </style>
</head>

<body>

  <script src="lib/d3/d3.min.js"></script>
  <script src="lib/d3-dsv/d3-dsv.min.js"></script>
  <script src="lib/d3-fetch/d3-fetch.min.js"></script>
  <script src="lib/d3-tip/d3-tip.js"></script>

  <div id="container">
    <h1>Mouse Brain Cell Data Visualization</h1>
    <div id="dropdownContainer">
      <div class="dropdownContent">
        <select id="clusterFilter" class="filter">
          <option value="">Select Cluster</option>
          <!-- Options will be populated dynamically -->
        </select>
        <select id="cellTypeFilter" class="filter">
          <option value="">Select Cell Type</option>
          <!-- Options will be populated dynamically -->
        </select>
      </div>
    </div>
    <img src="menu_icon.png" alt="Menu Icon" class="icon" id="menuIcon">
    <div id="plotLegendContainer">
      <div id="scatterplot">
        <!-- Scatter plot will be inserted here -->
      </div>
      <div class="legend">
        <!-- Legend will be inserted here -->
      </div>
    </div>
  </div>

  <script>
  //Shuffler
  function shuffle(array) {
    let currentIndex = array.length;

    // While there remain elements to shuffle...
    while (currentIndex != 0) {

      // Pick a remaining element...
      let randomIndex = Math.floor(Math.random() * currentIndex);
      currentIndex--;

      // And swap it with the current element.
      [array[currentIndex], array[randomIndex]] = [
        array[randomIndex], array[currentIndex]];
    }
  }
  const sampleSize = ([...arr], n = 1) => shuffle(arr).slice(0, n);

  // Get the data
  var pathToCsv = "MERFISH_all_neurons_with_clusters_cut.csv";		// path to csv
  // var pathToCsv = "MERFISH_all_neurons_with_clusters.csv";		// path to full csv
  var neighborhood = 'analysis_results/cell_neighborhood.csv';
  var brushing = false;
  var toolTip = d3.tip()
          .attr("class", "d3-tip")
          .offset([-12, 0])
          .html(function(d) {
            console.log(d);
            // Inject html, when creating your html I recommend editing the html within your index.html first
            return "<h5>" + d.names.replace(/-/, "-<br>")+"</h5>" +
                    "<table><thead><tr><td>center_x</td><td>center_y</td></tr></thead>"
                    + "<tbody><tr><td>"+d.x.toFixed(5)+"</td><td>"+d.y.toFixed(5)+"</td></tr></tbody>"
                    + "<thead><tr><td>cluster_no</td><td>cell_type</td></tr></thead>"
                    + "<tbody><tr><td>"+d['cluster']+"</td><td>"+d['cellType']+"</td></tr></tbody></table>"
          });

  Promise.all([
    d3.dsv(",", pathToCsv, function (d) {
      return {
       // format data attributes if required
       names: d.names,
       x: +d.center_x,
       y: +d.center_y,
       cluster: +d.cluster_no,
       cellType: d.cell_type,
    }}),
    d3.dsv(',', neighborhood, function(d) {
      return d;
    })
  ])
  .then(function (data) {
    tmp = data[0]
    shuffle(tmp)
    //Elements sliced
    tmp = tmp.slice(0, 50000)
    // console.log(data[0]);
    // console.log(data[1]); // you should see the data in your browser's developer tools console

    function updateScatterPlot() {
      const clusterFilter = document.getElementById("clusterFilter").value;
      const cellTypeFilter = document.getElementById("cellTypeFilter").value;

      // Filter data based on selected filters
      let filteredData = tmp;
      if (clusterFilter) {
        filteredData = filteredData.filter(d => d.cluster === parseInt(clusterFilter));
      }
      if (cellTypeFilter) {
        filteredData = filteredData.filter(d => d.cellType === cellTypeFilter);
      }

      // Sample scales for x and y axes
      const svg = d3.select("#scatterplot").select("svg");
      svg.selectAll("*").remove();

      const xScale = d3.scaleLinear()
        .domain(d3.extent(filteredData, d => d.x))
        .range([20, svg.attr("width")-20]);

      const yScale = d3.scaleLinear()
        .domain([0, d3.max(filteredData, d => d.y)])
        .range([svg.attr("height")-20, 20]);
      const brushElement = svg.append("g");

      // Create circles for filtered data points
      var dots = svg.selectAll("circle").data(filteredData);
      var dotsEnter = dots.enter()
        .append("circle")
        .attr("id", "data_point")
        .attr("r", 2.5)
        .attr("fill", d => colorScale(d.cluster))
        .on('mouseover', function(d) {
          if (!brushing) {
            d3.select(this).attr("opacity", 0.5);
            toolTip.show(d, this);
          }
        })
        .on('mouseout',  function(d) {
          if (!brushing) {
            d3.select(this).attr("opacity", 1);
            toolTip.hide(d, this);
          }
        });
      dots.merge(dotsEnter)
              .attr("cx", d => xScale(d.x))
              .attr("cy", d => yScale(d.y));
      dots.exit().remove();

      // Update legends
      const legendDiv = d3.select(".legend");
      legendDiv.selectAll("*").remove();
      const clusters = [...new Set(filteredData.map(d => d.cluster))];
      const legendContainer = legendDiv.append("div").attr("class", "legend-container");
      clusters.forEach(cluster => {
        const clusterData = filteredData.find(d => d.cluster === cluster);
        const legendItem =
                legendContainer
                        .append("div")
                        .attr("class", "legend-item")
                        .attr("id", cluster);
        // Add colored square box
        legendItem.append("div")
          .style("display", "inline-block")
          .style("width", "10px")
          .style("height", "10px")
          .style("background-color", colorScale(cluster))
          .style("border", "1px solid #fff")
          .style("vertical-align", "middle") // Align color box vertically
          .style("margin-right", "5px");
        // Add wrapped text in rectangular white shape
        legendItem.append("div")
          .style("color", colorScale(cluster))
          .text(`Cluster ${cluster} - ${clusterData.cellType}`)
          .style("vertical-align", "middle") // Align text vertically with color box
          .on("mouseover", function () {
            svg.selectAll("circle")
              //.attr("fill", d => d.cluster === cluster ? colorScale(d.cluster) : "#666")
              .attr("opacity", d => d.cluster === cluster ? 1 : 0.1);
          })
          .on("mouseout", function () {
            svg.selectAll("circle")//.attr("fill", d => colorScale(d.cluster))
            .attr("opacity", 1);
          });
      });
      legendContainer.style("border", "2px solid #fff")
        .style("padding", "5px")
        .style("border-radius", "5px");

      // Brush and linking
      const scatterplotWidth = +document.getElementById('scatterplot').clientWidth;
      d3.select("#scatterplot").append("svg").attr("width", scatterplotWidth).attr("height", 800);
      const brush = d3.brush()
              .extent([[0, 0], [+scatterplotWidth, +svg.attr("height")]])
              .on("start", brushStart)
              .on("brush", brushed)
              .on("end", brushEnd);
      brushElement.call(brush);
      // Brush 01: Start
      function brushStart() {
        brushing = true;
        svg.selectAll("circle").attr("opacity", 0.1);
        d3.selectAll(".legend-item").style("opacity", 0.1);
      }
      function brushed() {
        const selection = d3.event.selection;
        if (!selection) return;
        const [[x0, y0], [x1, y1]] = selection;
        const selectedClusters = new Set();
        // Only the selected point and the corresponding legend-item have their opacity set to 1.
        svg.selectAll("circle")
           .attr("opacity", 0.1)  // First set the transparency of all points to 0.1
           .filter(function(d) {
             const isSelected = x0 <= xScale(d.x) && xScale(d.x) <= x1 && y0 <= yScale(d.y) && yScale(d.y) <= y1;
             if (isSelected) {
               selectedClusters.add(d.cluster);
             }
             return isSelected;
          }).attr("opacity", 1);

        // update opacity of legend-items
        d3.selectAll(".legend-item")
          .style("opacity", function() {
            const cluster = parseInt(this.id.split('-').pop());
            return selectedClusters.has(cluster) ? 1 : 0.2;
          });
      }
      function brushEnd() {
        brushing = false;
        svg.selectAll("circle").attr("opacity", 1);
        d3.selectAll(".legend-item").style("opacity", 1);
      }

    }

    // Initialize scatter plot and legends
    const colorScale = d3.scaleOrdinal(d3.schemeCategory10);
    const scatterplotWidth = document.getElementById('scatterplot').clientWidth;
    const svg = d3.select("#scatterplot")
      .append("svg")
      .attr("width", scatterplotWidth)
      .attr("height", 800);
    svg.call(toolTip);

    // Populate cluster filter dropdown
    const clusterFilterSelect = document.getElementById("clusterFilter");
    const clusters = [...new Set(tmp.map(d => d.cluster))];
    clusters.forEach(cluster => {
      const option = document.createElement("option");
      option.text = `Cluster ${cluster}`;
      option.value = cluster;
      clusterFilterSelect.appendChild(option);
    });

    // Populate cell type filter dropdown
    const cellTypeFilterSelect = document.getElementById("cellTypeFilter");
    const cellTypes = [...new Set(tmp.map(d => d.cellType))];
    cellTypes.forEach(cellType => {
      const option = document.createElement("option");
      option.text = cellType;
      option.value = cellType;
      cellTypeFilterSelect.appendChild(option);
    });

    // Populate dropdown list
    const dropdownContainer = document.getElementById("dropdownContainer");
    const menuIcon = document.getElementById("menuIcon");
    const boundaryLeft = parseInt(window.getComputedStyle(dropdownContainer).left);
    const boundaryLeft_icon = parseInt(window.getComputedStyle(menuIcon).left);

    // Function to toggle dropdown visibility and position
    function toggleDropdown() {
      const currentLeft = parseInt(window.getComputedStyle(dropdownContainer).left);
      const currentLeft_icon = parseInt(window.getComputedStyle(menuIcon).left);
      const targetLeft = currentLeft === boundaryLeft ? (boundaryLeft + 410) : boundaryLeft; // Toggle between -100 and -500px
      const targetLeft_icon = currentLeft_icon === boundaryLeft_icon ? (boundaryLeft_icon + 410) : boundaryLeft_icon; // Toggle between -100 and -500px
      dropdownContainer.style.left = targetLeft + "px";
      menuIcon.style.left = targetLeft_icon + "px";

      if (targetLeft === boundaryLeft) {
        // Move dropdown to the middle of the page
        dropdownContainer.style.top = "80px";
        menuIcon.style.left = "-12%";
      } else {
        // Move dropdown back to the left
        dropdownContainer.style.top = "80px";
        menuIcon.style.left = "-12%";
      }
    }

    // Event listener for menu icon click
    menuIcon.addEventListener("click", toggleDropdown);

    // Event listener for filter dropdowns
    document.querySelectorAll(".filter").forEach(select => {
      select.addEventListener("change", updateScatterPlot);
    });

    // Initial scatter plot with default filters
    updateScatterPlot();
  }).catch(function (error) {
    console.log(error);
  });


</script>

</body>

</html>